# 哈希

哈希常见于一些困难的题目，目前见到的一般是原地哈希

## 原地哈希

这种题一般要求空间复杂度为 O(1)，也就是使用数组本身进行哈希的操作（标记）。

给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

进阶：你可以实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案吗？

示例 1：

输入：nums = [1,2,0]
输出：3
示例 2：

输入：nums = [3,4,-1,1]
输出：2
示例 3：

输入：nums = [7,8,9,11,12]
输出：1

提示：

0 <= nums.length <= 300
$-2^31$ <= nums[i] <= $2^31 - 1$

本题可以考虑的方法：哈希，即将数组中出现的正整数存入哈希表中，再从 1 开始逐个判断在不在哈希表中。当然这样必不可能是原地算法，所以必须考虑如何将哈希表放在原来的数组中。

假设数组有 N 个数，最小没有出现的正整数只能在[1,N+1]之中出现。如果这 N 个数恰好为[1,N]则答案为 N+1，否则我们可以将所有[1,N]范围中的数放入数组中。如果找到数 x 在[1,N]，则将位置 x-1 的数打上标记，比如转化为负数。

然而需要考虑的是，数组中的数可能存在非正整数和大于 N 的数。对于负数来说可能和标记混淆，因此需要提前将所有非正整数转化为不影响标记的数字，比如 N+1。

最后遍历数组，找到第一个不为负数的下标 i，答案即为 i+1，否则答案为 N+1

```java
public int firstMissingPositive(int[] nums) {
    int len = nums.length;
    for (int i = 0; i < len; i++) {
        if (nums[i] <= 0) {
            nums[i] = len + 1;
        }
    }

    for (int i = 0; i < len; i++) {
        int num = Math.abs(nums[i]);
        if (num <= len) {
            nums[num - 1] = -1 * Math.abs(nums[num - 1]);
        }
    }

    for (int i = 0; i < len; i++) {
        if (nums[i] > 0) {
            return i + 1;
        }
    }
    return len+1;
}
```
