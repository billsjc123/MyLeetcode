# 排列

## 1053.交换一次的先前排列

给你一个正整数的数组 A（其中的元素不一定完全不同），请你返回可在**一次交换（交换两数字 A[i] 和 A[j] 的位置）后得到的、按字典序排列小于 A 的最大可能排列。**

如果无法这么操作，就请返回原数组。

示例 1：

输入：arr = [3,2,1]
输出：[3,1,2]
解释：交换 2 和 1
示例 2：

输入：arr = [1,1,5]
输出：[1,1,5]
解释：已经是最小排列
示例 3：

输入：arr = [1,9,4,6,7]
输出：[1,7,4,6,9]
解释：交换 9 和 7
示例 4：

输入：arr = [3,1,1,3]
输出：[1,3,1,3]
解释：交换 1 和 3

### 解法

1.  要想排列比原先小，必须得将两个降序的数字进行交换
2.  要想排列尽可能大，则必须保证前面的数字能不动就不动，尽量在最后面进行交换

基于以上两点原则，需要倒序查找非递减序列直到找到第一个递减的位置 i，此时从 i+1 到 len 的所有元素是非递减的且 arr[i]一定小于 arr[i+1]。

但是要获得尽可能大的排列，因此换到 arr[i]的这个数越大越好，且 arr[i]被换到的位置越靠近左边越好，因此从最后向前找最左边的小于 arr[i]的数字进行交换

```java
public int[] prevPermOpt1(int[] arr) {
    int len = arr.length;
    if (len == 1)
        return arr;

    // 倒序寻找非递减序列的起始位置
    int i = len - 1;

    // 如果最后两个值是递减的，则直接交换
    if (arr[i - 1] > arr[i]) {
        swap(arr, i, i - 1);
        return arr;
    }
    for (; i >= 1 && arr[i - 1] <= arr[i]; i--)
        ;
    // 整个数组为非递减
    if (i == 0)
        return arr;

    i--;
    for (int j = len - 1; j > i; j--) {
        if(arr[j]==arr[j-1])
            continue;
        if (arr[j] < arr[i]) {
            swap(arr, i, j);
            return arr;
        }
    }

    return arr;
}
```
