# Leetcode 968.监控二叉树

给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视其**父对象、自身及其直接子对象**。

计算监控树的所有节点所需的**最小**摄像头数量。

根据题意，如果可知以下信息
1.  摄像头放在叶子节点上，则可以监视该节点、父节点（最多2个）
2.  摄像头放在叶子节点的父节点，可以监视该节点、直接子节点、父节点（最多4个）
3.  摄像头放在根节点，可以监视该节点、直接子节点（最多3个）

因为题目求摄像头数量最小值，根据贪心思想，每次放在叶子节点的父节点上能监视最多的节点。

因此，本题的思路是，从叶子节点开始像上查找，如果当前节点是叶子节点的父节点，则安装摄像头，如果该节点是摄像头节点的父节点，则可以从树中删去该节点。

因此对于每个节点有三种状态，对应三种返回值
1.  如果该节点是叶子节点，则返回0
2.  如果该节点是叶子节点的父节点返回1
3.  其他情况返回2 **（监视器节点的父节点和null是等价的，因为都相当于从树中删去了）**

注意多种情况的讨论，本题中，左子节点可能返回3种情况，右子节点可能返回3种情况，所以有9种情况。难道要if-else大法？当然不行。
这种题就是要细心分析几种情况的相似性
比如：
- 如果左右子节点中有一个是叶子节点，那么该节点一定是监视器节点
- 如果左右子节点中有一个是监视器节点，那么该节点一定是其他情况节点（此时左右子节点已经无叶子节点）
- 若都不满足以上两条，则说明左右子节点都是情况3的节点，相当于左右子节点都是null，因此该节点可以看作叶子节点。

```java
class Solution {
   int result = 0;
    public int minCameraCover(TreeNode root) {
        if(dfs(root)==0)result++;
        return result;
    }
    /*
     * returnVal: 
     * - 0: leaf 
     * - 1: parent of leaf
     * - 2: null
     * but without a camera
     */
    public int dfs(TreeNode node) {
        if (node == null)
            return 2;
        int l = dfs(node.left), r = dfs(node.right);
        if (l * r == 0) {
            result++;
            return 1;
        }
        if(l == 1 || r == 1){
            return 2;
        }
        // if(l==2 && r == 2) -- leaf
        return 0;
    }
}
```